- name: Generate Changelog
        run: |
          python3 << 'EOF'
          import subprocess
          import sys
          from datetime import datetime
          from collections import defaultdict

          def run_git_log(args):
              try:
                  # We add %x00 (a null byte) at the end of each formatted entry.
                  # This acts as a reliable delimiter for commits.
                  log_format_arg = next(arg for arg in args if arg.startswith('--pretty=format:'))
                  args[args.index(log_format_arg)] = log_format_arg + '%x00'
                  
                  result = subprocess.run(['git'] + args, capture_output=True, text=True, check=True)
                  
                  # We split by the null byte, not by newline. This keeps multi-line descriptions intact.
                  return result.stdout.strip().split('\x00') if result.stdout.strip() else []
              except (subprocess.CalledProcessError, StopIteration) as e:
                  print(f"Error running git or processing args: {e}")
                  sys.exit(1)

          def get_commits_by_tag():
              try:
                  latest_tag = subprocess.run(
                      ['git', 'describe', '--tags', '--abbrev=0'],
                      capture_output=True, text=True, check=True
                  ).stdout.strip()

                  tag_date = subprocess.run(
                      ['git', 'log', '-1', '--format=%ad', '--date=short', latest_tag],
                      capture_output=True, text=True, check=True
                  ).stdout.strip()

                  # Using the corrected run_git_log function
                  tagged = run_git_log([
                      'log', latest_tag,
                      '--pretty=format:%s|||%b|||%an|||%ad|||%H',
                      '--date=short',
                      '--invert-grep',
                      '--grep=docs: update changelog',
                      '--grep=changelog.yml',
                      '--grep=\\[skip ci\\]'
                  ])

                  unreleased = run_git_log([
                      'log', f'{latest_tag}..HEAD',
                      '--pretty=format:%s|||%b|||%an|||%ad|||%H',
                      '--date=short',
                      '--invert-grep',
                      '--grep=docs: update changelog',
                      '--grep=changelog.yml',
                      '--grep=\\[skip ci\\]'
                  ])

                  return {
                      'tagged': {latest_tag: {'commits': tagged, 'date': tag_date}},
                      'unreleased': unreleased
                  }

              except subprocess.CalledProcessError:
                  all_commits = run_git_log([
                      'log',
                      '--pretty=format:%s|||%b|||%an|||%ad|||%H',
                      '--date=short',
                      '--invert-grep',
                      '--grep=docs: update changelog',
                      '--grep=changelog.yml',
                      '--grep=\\[skip ci\\]'
                  ])
                  return {
                      'tagged': {},
                      'unreleased': all_commits
                  }

          def categorize_commit(subject, body):
              text = (subject + ' ' + body).lower()
              if any(x in text for x in ['security', 'vulnerability', 'cve', 'exploit']):
                  return 'security'
              if any(x in text for x in ['breaking change', 'breaking:', 'break:']):
                  return 'breaking'
              if any(x in text for x in ['deprecat', 'obsolete', 'phase out']):
                  return 'deprecated'
              if any(x in text for x in ['remove', 'delete', 'drop', 'eliminate']):
                  return 'removed'
              if any(x in text for x in ['fix', 'resolve', 'correct', 'patch', 'bug', 'issue']):
                  return 'fixed'
              if any(x in text for x in ['add', 'new', 'create', 'implement', 'feat', 'feature']):
                  return 'added'
              return 'changed'

          def format_commit_entry(commit):
              entry = f"- **{commit['subject']}** ({commit['date']} â€“ {commit['author']})"
              # This part of the code was already correct, but it wasn't receiving the body data.
              body = commit['body'].strip()
              if body:
                  lines = [line.strip() for line in body.splitlines() if line.strip()]
                  for line in lines:
                      entry += f"\n  - {line}" # Added a dash for better formatting of list items
              return entry

          def parse_commits(lines):
              commits = []
              for line in lines:
                  if not line: continue
                  parts = line.split('|||')
                  if len(parts) >= 5:
                      subject, body, author, date, hash_id = map(str.strip, parts)
                      commits.append({
                          'subject': subject,
                          'body': body,
                          'author': author,
                          'date': date,
                          'hash': hash_id[:7]
                      })
              return commits

          def build_changelog(commits_by_version):
              sections = [
                  ('security', 'Security'),
                  ('breaking', 'Breaking Changes'),
                  ('deprecated', 'Deprecated'),
                  ('added', 'Added'),
                  ('changed', 'Changed'),
                  ('fixed', 'Fixed'),
                  ('removed', 'Removed')
              ]

              lines = [
                  "# Changelog",
                  "",
                  "All notable changes to this project will be documented in this file.",
                  "",
                  "The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),",
                  "and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).",
                  ""
              ]

              unreleased = parse_commits(commits_by_version.get('unreleased', []))
              if unreleased:
                  lines.append("## [Unreleased]")
                  lines.append("")
                  categorized = defaultdict(list)
                  for commit in unreleased:
                      cat = categorize_commit(commit['subject'], commit['body'])
                      categorized[cat].append(commit)

                  has_content = False
                  for key, label in sections:
                      if categorized[key]:
                          has_content = True
                          lines.append(f"### {label}")
                          lines.append("")
                          for commit in categorized[key]:
                              lines.append(format_commit_entry(commit))
                          lines.append("")
                  if not has_content:
                      lines.append("_No unreleased changes._\n")

              # Sort tags chronologically if possible, simplistic sort for now
              sorted_tags = sorted(commits_by_version.get('tagged', {}).items(), key=lambda item: item[1].get('date', ''), reverse=True)

              for tag, info in sorted_tags:
                  commits = parse_commits(info.get('commits', []))
                  if not commits: continue
                  lines.append(f"## [{tag}] - {info.get('date', '')}")
                  lines.append("")
                  categorized = defaultdict(list)
                  for commit in commits:
                      cat = categorize_commit(commit['subject'], commit['body'])
                      categorized[cat].append(commit)
                  
                  has_content = False
                  for key, label in sections:
                      if categorized[key]:
                          has_content = True
                          lines.append(f"### {label}")
                          lines.append("")
                          for commit in categorized[key]:
                              lines.append(format_commit_entry(commit))
                          lines.append("")
                  if not has_content:
                      lines.append("_No changes for this version._\n")

              return "\n".join(lines)

          try:
              commit_data = get_commits_by_tag()
              changelog = build_changelog(commit_data)
              with open("CHANGELOG.md", "w", encoding="utf-8") as f:
                  f.write(changelog)
              print("Changelog generated.")
          except Exception as e:
              import traceback
              print(f"Error generating changelog: {e}")
              traceback.print_exc()
              sys.exit(1)
          EOF