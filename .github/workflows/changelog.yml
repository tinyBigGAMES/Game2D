name: Update Changelog

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:

jobs:
  update-changelog:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Generate Full Keep a Changelog Format
        run: |
          python3 << 'EOF'
          import subprocess
          import re
          import sys
          from datetime import datetime
          from collections import defaultdict

          def get_filtered_commits():
              """Get commits excluding workflow update noise"""
              cmd = [
                  'git', 'log', '--pretty=format:%s|||%b|||%an|||%ad|||%H',
                  '--date=short',
                  '--grep=docs: update changelog',
                  '--grep=Update changelog.yml',
                  '--grep=Create changelog.yml',
                  '--grep=\\[skip ci\\]',
                  '--invert-grep'
              ]
              try:
                  result = subprocess.run(cmd, capture_output=True, text=True, check=True)
                  return result.stdout.strip().split('\n') if result.stdout.strip() else []
              except subprocess.CalledProcessError as e:
                  print(f"Error getting commits: {e}")
                  return []

          def get_commit_tags():
              """Get commits with their associated tags"""
              try:
                  cmd = ['git', 'log', '--tags', '--simplify-by-decoration', '--pretty=format:%H|||%D']
                  result = subprocess.run(cmd, capture_output=True, text=True, check=True)
                  
                  commit_tags = {}
                  for line in result.stdout.strip().split('\n'):
                      if line.strip():
                          parts = line.split('|||')
                          if len(parts) >= 2:
                              commit_hash, refs = parts[0], parts[1]
                              if 'tag:' in refs:
                                  for ref in refs.split(','):
                                      if 'tag:' in ref:
                                          tag_name = ref.replace('tag:', '').strip()
                                          commit_tags[commit_hash] = tag_name
                                          break
                  return commit_tags
              except subprocess.CalledProcessError:
                  return {}

          def categorize_commit(subject, body):
              """Categorize based on keywords in subject/body"""
              text = (subject + ' ' + body).lower()

              if any(word in text for word in ['security', 'vulnerability', 'cve', 'exploit']):
                  return 'security'
              if any(phrase in text for phrase in ['breaking change', 'breaking:', 'break:']):
                  return 'breaking'
              if any(word in text for word in ['deprecat', 'obsolete', 'phase out']):
                  return 'deprecated'
              if any(word in text for word in ['remove', 'delete', 'drop', 'eliminate']):
                  return 'removed'
              if any(word in text for word in ['fix', 'resolve', 'correct', 'patch', 'bug', 'issue']):
                  return 'fixed'
              if any(word in text for word in ['add', 'new', 'create', 'implement', 'feat', 'feature']):
                  return 'added'
              return 'changed'

          def format_commit_entry(commit):
              """Format a commit with optional body lines"""
              entry = f"- **{commit['subject']}** ({commit['date']} - {commit['author']})"
              if commit['body']:
                  body_lines = [line.strip() for line in commit['body'].split('\n') if line.strip()]
                  if body_lines:
                      entry += "\n"
                      for line in body_lines:
                          entry += f"  {line}\n"
              return entry

          def generate_full_changelog():
              commits = get_filtered_commits()
              commit_tags = get_commit_tags()
              categorized = defaultdict(lambda: defaultdict(list))

              # Get latest tag for determining what's unreleased
              try:
                  latest_tag_result = subprocess.run(['git', 'describe', '--tags', '--abbrev=0'], 
                                                   capture_output=True, text=True, check=True)
                  latest_tag = latest_tag_result.stdout.strip()
              except subprocess.CalledProcessError:
                  latest_tag = None

              for line in commits:
                  if not line.strip():
                      continue
                  parts = line.split('|||')
                  if len(parts) >= 5:
                      subject, body, author, date, hash_id = map(str.strip, parts[:5])
                      category = categorize_commit(subject, body)
                      
                      # Determine if this commit is tagged or unreleased
                      commit_tag = commit_tags.get(hash_id, None)
                      section = commit_tag if commit_tag else 'unreleased'
                      
                      categorized[section][category].append({
                          'subject': subject,
                          'body': body,
                          'author': author,
                          'date': date,
                          'hash': hash_id[:7]
                      })

              changelog_lines = [
                  "# Changelog",
                  "",
                  "All notable changes to this project will be documented in this file.",
                  "",
                  "The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),",
                  "and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).",
                  "",
                  "## [Unreleased]",
                  ""
              ]

              sections = [
                  ('security', 'Security'),
                  ('breaking', 'Breaking Changes'),
                  ('deprecated', 'Deprecated'),
                  ('added', 'Added'),
                  ('changed', 'Changed'),
                  ('fixed', 'Fixed'),
                  ('removed', 'Removed')
              ]

              # Show unreleased changes first
              for section_key, section_label in sections:
                  if categorized['unreleased'][section_key]:
                      changelog_lines.append(f"### {section_label}")
                      for commit in categorized['unreleased'][section_key]:
                          changelog_lines.append(format_commit_entry(commit))
                      changelog_lines.append("")

              # Show tagged releases (sorted by tag name, newest first)
              tagged_sections = [k for k in categorized.keys() if k != 'unreleased']
              tagged_sections.sort(reverse=True)
              
              for tag_name in tagged_sections:
                  # Get tag date
                  try:
                      tag_date_cmd = ['git', 'log', '-1', '--format=%ad', '--date=short', tag_name]
                      tag_date_result = subprocess.run(tag_date_cmd, capture_output=True, text=True, check=True)
                      tag_date = tag_date_result.stdout.strip()
                  except subprocess.CalledProcessError:
                      tag_date = "Unknown"
                  
                  changelog_lines.append(f"## [{tag_name}] - {tag_date}")
                  changelog_lines.append("")
                  
                  for section_key, section_label in sections:
                      if categorized[tag_name][section_key]:
                          changelog_lines.append(f"### {section_label}")
                          for commit in categorized[tag_name][section_key]:
                              changelog_lines.append(format_commit_entry(commit))
                          changelog_lines.append("")

              return "\n".join(changelog_lines)

          try:
              content = generate_full_changelog()
              with open('CHANGELOG.md', 'w', encoding='utf-8') as f:
                  f.write(content)
              print("✅ Successfully generated changelog.")
          except Exception as e:
              print(f"❌ Error generating changelog: {e}")
              sys.exit(1)
          EOF

      - name: Commit Updated Changelog
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add CHANGELOG.md
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "docs: update changelog [skip ci]"
            git push
          fi