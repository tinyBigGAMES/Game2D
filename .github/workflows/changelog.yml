name: Update Changelog

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:

jobs:
  update-changelog:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.x'

      - name: Generate Full Keep a Changelog Format
        run: |
          python3 << 'EOF'
          import subprocess
          import re
          import sys
          from datetime import datetime
          from collections import defaultdict

          def get_filtered_commits():
              """Get commits excluding workflow update noise"""
              cmd = [
                  'git', 'log', '--pretty=format:%s|||%b|||%an|||%ad|||%H',
                  '--date=short',
                  '--grep=docs: update changelog',
                  '--grep=Update changelog.yml',
                  '--grep=Create changelog.yml',
                  '--grep=\\[skip ci\\]',
                  '--invert-grep'
              ]
              try:
                  result = subprocess.run(cmd, capture_output=True, text=True, check=True)
                  return result.stdout.strip().split('\n') if result.stdout.strip() else []
              except subprocess.CalledProcessError as e:
                  print(f"Error getting commits: {e}")
                  return []

          def get_commits_by_tag():
              """Get commits organized by tag, with unreleased commits separate"""
              try:
                  # Get the latest tag
                  latest_tag_result = subprocess.run(['git', 'describe', '--tags', '--abbrev=0'], 
                                                   capture_output=True, text=True, check=True)
                  latest_tag = latest_tag_result.stdout.strip()
                  
                  # Get unreleased commits (since latest tag)
                  unreleased_cmd = [
                      'git', 'log', f'{latest_tag}..HEAD', '--pretty=format:%s|||%b|||%an|||%ad|||%H',
                      '--date=short',
                      '--grep=docs: update changelog',
                      '--grep=Update changelog.yml',
                      '--grep=Create changelog.yml',
                      '--grep=\\[skip ci\\]',
                      '--invert-grep'
                  ]
                  unreleased_result = subprocess.run(unreleased_cmd, capture_output=True, text=True, check=True)
                  unreleased_commits = unreleased_result.stdout.strip().split('\n') if unreleased_result.stdout.strip() else []
                  
                  # Get ALL commits, then we'll separate them
                  all_commits_cmd = [
                      'git', 'log', '--pretty=format:%s|||%b|||%an|||%ad|||%H',
                      '--date=short',
                      '--grep=docs: update changelog',
                      '--grep=Update changelog.yml',
                      '--grep=Create changelog.yml',
                      '--grep=\\[skip ci\\]',
                      '--invert-grep'
                  ]
                  all_result = subprocess.run(all_commits_cmd, capture_output=True, text=True, check=True)
                  all_commits = all_result.stdout.strip().split('\n') if all_result.stdout.strip() else []
                  
                  # Get unreleased commit hashes for filtering
                  unreleased_hashes = set()
                  for line in unreleased_commits:
                      if line.strip():
                          parts = line.split('|||')
                          if len(parts) >= 5:
                              unreleased_hashes.add(parts[4].strip())
                  
                  # Tagged commits are all commits minus unreleased ones
                  tagged_commits = []
                  for line in all_commits:
                      if line.strip():
                          parts = line.split('|||')
                          if len(parts) >= 5:
                              commit_hash = parts[4].strip()
                              if commit_hash not in unreleased_hashes:
                                  tagged_commits.append(line)
                  
                  # Get tag date
                  tag_date_cmd = ['git', 'log', '-1', '--format=%ad', '--date=short', latest_tag]
                  tag_date_result = subprocess.run(tag_date_cmd, capture_output=True, text=True, check=True)
                  tag_date = tag_date_result.stdout.strip()
                  
                  return {
                      'unreleased': unreleased_commits,
                      'tagged': {latest_tag: {'commits': tagged_commits, 'date': tag_date}}
                  }
                  
              except subprocess.CalledProcessError:
                  # No tags exist, everything is unreleased
                  all_commits_cmd = [
                      'git', 'log', '--pretty=format:%s|||%b|||%an|||%ad|||%H',
                      '--date=short',
                      '--grep=docs: update changelog',
                      '--grep=Update changelog.yml',
                      '--grep=Create changelog.yml',
                      '--grep=\\[skip ci\\]',
                      '--invert-grep'
                  ]
                  result = subprocess.run(all_commits_cmd, capture_output=True, text=True, check=True)
                  all_commits = result.stdout.strip().split('\n') if result.stdout.strip() else []
                  return {
                      'unreleased': all_commits,
                      'tagged': {}
                  }

          def categorize_commit(subject, body):
              """Categorize based on keywords in subject/body"""
              text = (subject + ' ' + body).lower()

              if any(word in text for word in ['security', 'vulnerability', 'cve', 'exploit']):
                  return 'security'
              if any(phrase in text for phrase in ['breaking change', 'breaking:', 'break:']):
                  return 'breaking'
              if any(word in text for word in ['deprecat', 'obsolete', 'phase out']):
                  return 'deprecated'
              if any(word in text for word in ['remove', 'delete', 'drop', 'eliminate']):
                  return 'removed'
              if any(word in text for word in ['fix', 'resolve', 'correct', 'patch', 'bug', 'issue']):
                  return 'fixed'
              if any(word in text for word in ['add', 'new', 'create', 'implement', 'feat', 'feature']):
                  return 'added'
              return 'changed'

          def format_commit_entry(commit):
              """Format a commit with optional body lines"""
              entry = f"- **{commit['subject']}** ({commit['date']} - {commit['author']})"
              
              if commit['body'] and commit['body'].strip():
                  body_lines = [line.strip() for line in commit['body'].split('\n') if line.strip()]
                  if body_lines:
                      entry += "\n"
                      for line in body_lines:
                          entry += f"  {line}\n"
              else:
                  entry += "\n"
              
              return entry

          def generate_full_changelog():
              commit_data = get_commits_by_tag()
              categorized = defaultdict(lambda: defaultdict(list))

              # Process unreleased commits
              for line in commit_data['unreleased']:
                  if not line.strip():
                      continue
                  parts = line.split('|||')
                  if len(parts) >= 5:
                      subject, body, author, date, hash_id = map(str.strip, parts[:5])
                      category = categorize_commit(subject, body)
                      categorized['unreleased'][category].append({
                          'subject': subject,
                          'body': body,
                          'author': author,
                          'date': date,
                          'hash': hash_id[:7]
                      })

              # Process tagged commits
              for tag_name, tag_info in commit_data['tagged'].items():
                  for line in tag_info['commits']:
                      if not line.strip():
                          continue
                      parts = line.split('|||')
                      if len(parts) >= 5:
                          subject, body, author, date, hash_id = map(str.strip, parts[:5])
                          category = categorize_commit(subject, body)
                          categorized[tag_name][category].append({
                              'subject': subject,
                              'body': body,
                              'author': author,
                              'date': date,
                              'hash': hash_id[:7]
                          })

              changelog_lines = [
                  "# Changelog",
                  "",
                  "All notable changes to this project will be documented in this file.",
                  "",
                  "The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),",
                  "and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).",
                  "",
                  "## [Unreleased]",
                  ""
              ]

              sections = [
                  ('security', 'Security'),
                  ('breaking', 'Breaking Changes'),
                  ('deprecated', 'Deprecated'),
                  ('added', 'Added'),
                  ('changed', 'Changed'),
                  ('fixed', 'Fixed'),
                  ('removed', 'Removed')
              ]

              # Show unreleased changes first
              has_unreleased = False
              for section_key, section_label in sections:
                  if categorized['unreleased'][section_key]:
                      has_unreleased = True
                      changelog_lines.append(f"### {section_label}")
                      for commit in categorized['unreleased'][section_key]:
                          changelog_lines.append(format_commit_entry(commit))
                      changelog_lines.append("")
              
              if not has_unreleased:
                  changelog_lines.append("No unreleased changes.")
                  changelog_lines.append("")

              # Show tagged releases
              for tag_name, tag_info in commit_data['tagged'].items():
                  changelog_lines.append(f"## [{tag_name}] - {tag_info['date']}")
                  changelog_lines.append("")
                  
                  has_changes = False
                  for section_key, section_label in sections:
                      if categorized[tag_name][section_key]:
                          has_changes = True
                          changelog_lines.append(f"### {section_label}")
                          for commit in categorized[tag_name][section_key]:
                              changelog_lines.append(format_commit_entry(commit))
                          changelog_lines.append("")
                  
                  if not has_changes:
                      changelog_lines.append("Initial release.")
                      changelog_lines.append("")

              return "\n".join(changelog_lines)

          try:
              content = generate_full_changelog()
              with open('CHANGELOG.md', 'w', encoding='utf-8') as f:
                  f.write(content)
              print("Successfully generated changelog.")
          except Exception as e:
              print(f"Error generating changelog: {e}")
              sys.exit(1)
          EOF

      - name: Commit Updated Changelog
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add CHANGELOG.md
          if git diff --staged --quiet; then
            echo "No changes to commit"
          else
            git commit -m "docs: update changelog [skip ci]"
            git push
          fi